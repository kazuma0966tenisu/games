<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tank Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #e0e0e0;
            overflow: hidden;
            touch-action: none; /* スワイプによるスクロールを防止 */
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* UIレイヤー自体はタッチイベントをブロックしない */
        }
        .instruction {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            font-family: sans-serif;
            color: #333;
            font-weight: bold;
            pointer-events: none;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<div id="ui-layer">
    <div class="instruction">左半分で移動・右半分で射撃</div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // 画面サイズをウィンドウに合わせる
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ゲーム状態
    let gameOver = false;
    let score = 0;

    // 入力情報（バーチャルジョイスティック）
    const input = {
        left: { active: false, x: 0, y: 0, originX: 0, originY: 0, id: null },
        right: { active: false, x: 0, y: 0, originX: 0, originY: 0, id: null }
    };

    // タッチイベントの処理
    function handleTouch(e) {
        e.preventDefault();
        const halfWidth = canvas.width / 2;

        // 一旦アクティブ状態をリセット
        let leftActive = false;
        let rightActive = false;

        for (let i = 0; i < e.touches.length; i++) {
            const touch = e.touches[i];
            if (touch.clientX < halfWidth) {
                // 左側（移動）
                leftActive = true;
                if (!input.left.active) {
                    input.left.originX = touch.clientX;
                    input.left.originY = touch.clientY;
                    input.left.id = touch.identifier;
                }
                input.left.active = true;
                input.left.x = touch.clientX;
                input.left.y = touch.clientY;
            } else {
                // 右側（射撃）
                rightActive = true;
                if (!input.right.active) {
                    input.right.originX = touch.clientX;
                    input.right.originY = touch.clientY;
                    input.right.id = touch.identifier;
                }
                input.right.active = true;
                input.right.x = touch.clientX;
                input.right.y = touch.clientY;
            }
        }
        
        if (!leftActive) input.left.active = false;
        if (!rightActive) input.right.active = false;
    }

    canvas.addEventListener('touchstart', handleTouch, {passive: false});
    canvas.addEventListener('touchmove', handleTouch, {passive: false});
    canvas.addEventListener('touchend', handleTouch, {passive: false});
    canvas.addEventListener('touchcancel', handleTouch, {passive: false});

    // オブジェクト定義
    class Tank {
        constructor(x, y, color, isPlayer) {
            this.x = x;
            this.y = y;
            this.width = 30;
            this.height = 30;
            this.color = color;
            this.isPlayer = isPlayer;
            this.angle = 0;
            this.speed = isPlayer ? 3 : 1.5;
            this.cooldown = 0;
            this.dead = false;
        }

        draw() {
            if (this.dead) return;
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // 車体
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
            
            // 砲台
            ctx.rotate(this.angle);
            ctx.fillStyle = '#333';
            ctx.fillRect(0, -5, 25, 10);
            
            ctx.restore();
        }

        update() {
            if (this.cooldown > 0) this.cooldown--;
        }
    }

    class Bullet {
        constructor(x, y, vx, vy, isPlayer) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.radius = 4;
            this.isPlayer = isPlayer;
            this.bounces = 0;
            this.maxBounces = 1; // 1回反射できる
            this.dead = false;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#000';
            ctx.fill();
            ctx.closePath();
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;

            // 画面端での反射
            if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                this.vx *= -1;
                this.bounces++;
            }
            if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) {
                this.vy *= -1;
                this.bounces++;
            }

            if (this.bounces > this.maxBounces) {
                this.dead = true;
            }
        }
    }

    class Block {
        constructor(x, y, w, h) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        draw() {
            ctx.fillStyle = '#8B4513'; // 木箱のような色
            ctx.fillRect(this.x, this.y, this.w, this.h);
            ctx.strokeStyle = '#5c2e0b';
            ctx.strokeRect(this.x, this.y, this.w, this.h);
        }
    }

    // ゲームの初期化
    let player;
    let enemies = [];
    let bullets = [];
    let blocks = [];

    function initGame() {
        player = new Tank(canvas.width / 2, canvas.height - 100, '#0074D9', true);
        enemies = [];
        bullets = [];
        blocks = [];
        score = 0;
        gameOver = false;

        // ブロックを適当に配置
        blocks.push(new Block(canvas.width/4, canvas.height/3, 100, 40));
        blocks.push(new Block(canvas.width*0.6, canvas.height/2, 40, 100));

        spawnEnemy();
    }

    function spawnEnemy() {
        const ex = Math.random() * (canvas.width - 60) + 30;
        const ey = Math.random() * (canvas.height / 2);
        enemies.push(new Tank(ex, ey, '#FF4136', false));
    }

    // 衝突判定 (AABB)
    function checkCollision(r1, r2) {
        return (r1.x - r1.width/2 < r2.x + r2.w &&
                r1.x + r1.width/2 > r2.x &&
                r1.y - r1.height/2 < r2.y + r2.h &&
                r1.y + r1.height/2 > r2.y);
    }

    // ジョイスティックの描画
    function drawJoystick(stick, color) {
        if (!stick.active) return;
        ctx.beginPath();
        ctx.arc(stick.originX, stick.originY, 40, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fill();
        ctx.closePath();

        // 制限された範囲内で操作用の円を描画
        let dx = stick.x - stick.originX;
        let dy = stick.y - stick.originY;
        let dist = Math.hypot(dx, dy);
        let maxDist = 40;
        if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
        }

        ctx.beginPath();
        ctx.arc(stick.originX + dx, stick.originY + dy, 20, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();
    }

    // メインループ
    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (gameOver) {
            ctx.fillStyle = '#000';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
            ctx.font = '20px sans-serif';
            ctx.fillText('画面タップでリトライ', canvas.width/2, canvas.height/2 + 40);
            
            // リトライ処理
            canvas.onclick = () => { initGame(); canvas.onclick = null; };
            canvas.ontouchend = () => { initGame(); canvas.ontouchend = null; };
            requestAnimationFrame(gameLoop);
            return;
        }

        // --- プレイヤー処理 ---
        if (input.left.active) {
            let dx = input.left.x - input.left.originX;
            let dy = input.left.y - input.left.originY;
            let dist = Math.hypot(dx, dy);
            if (dist > 10) {
                let vx = (dx / dist) * player.speed;
                let vy = (dy / dist) * player.speed;
                
                player.x += vx;
                player.y += vy;

                // 画面外に出ないようにする
                player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, player.x));
                player.y = Math.max(player.height/2, Math.min(canvas.height - player.height/2, player.y));
            }
        }

        if (input.right.active) {
            let dx = input.right.x - input.right.originX;
            let dy = input.right.y - input.right.originY;
            if (Math.hypot(dx, dy) > 10) {
                player.angle = Math.atan2(dy, dx);
                
                // 射撃
                if (player.cooldown <= 0) {
                    const bx = player.x + Math.cos(player.angle) * 25;
                    const by = player.y + Math.sin(player.angle) * 25;
                    const speed = 6;
                    bullets.push(new Bullet(bx, by, Math.cos(player.angle) * speed, Math.sin(player.angle) * speed, true));
                    player.cooldown = 40; // 発射間隔
                }
            }
        }
        player.update();

        // --- 敵処理 ---
        if (enemies.length === 0) {
            // 敵が全滅したら補充
            setTimeout(spawnEnemy, 1000);
            setTimeout(spawnEnemy, 2000);
        }

        enemies.forEach(enemy => {
            // シンプルなAI: プレイヤーの方を向いてたまに撃つ
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            enemy.angle = Math.atan2(dy, dx);
            
            if (Math.random() < 0.01 && enemy.cooldown <= 0) {
                const speed = 4;
                bullets.push(new Bullet(enemy.x, enemy.y, Math.cos(enemy.angle) * speed, Math.sin(enemy.angle) * speed, false));
                enemy.cooldown = 60;
            }
            enemy.update();
            enemy.draw();
        });

        // --- ブロック処理 ---
        blocks.forEach(block => block.draw());

        // --- 弾処理 ---
        bullets.forEach(bullet => {
            bullet.update();
            bullet.draw();

            // ブロックとの衝突（弾の反射）
            blocks.forEach(block => {
                if (bullet.x > block.x && bullet.x < block.x + block.w &&
                    bullet.y > block.y && bullet.y < block.y + block.h) {
                    // 簡単な反射計算
                    bullet.vx *= -1;
                    bullet.vy *= -1;
                    bullet.bounces++;
                }
            });

            // 当たり判定 (弾 vs プレイヤー/敵)
            if (bullet.isPlayer) {
                enemies.forEach(enemy => {
                    if (!enemy.dead && Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y) < enemy.width/2 + bullet.radius) {
                        enemy.dead = true;
                        bullet.dead = true;
                        score += 10;
                    }
                });
            } else {
                if (Math.hypot(bullet.x - player.x, bullet.y - player.y) < player.width/2 + bullet.radius) {
                    gameOver = true;
                }
            }
        });

        // 死んだエンティティの削除
        enemies = enemies.filter(e => !e.dead);
        bullets = bullets.filter(b => !b.dead);

        // --- 描画 ---
        player.draw();

        // ジョイスティックの描画（画面の上に重ねる）
        drawJoystick(input.left, 'rgba(0, 116, 217, 0.7)');
        drawJoystick(input.right, 'rgba(255, 65, 54, 0.7)');

        // スコア表示
        ctx.fillStyle = '#000';
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('Score: ' + score, 10, 30);

        requestAnimationFrame(gameLoop);
    }

    initGame();
    gameLoop();

</script>
</body>
</html>

