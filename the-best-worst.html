<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tank Game - Custom Controls</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #e0e0e0;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
        /* 縦画面のときに表示する警告オーバーレイ */
        #portrait-warning {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #333;
            color: white;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: sans-serif;
            text-align: center;
        }
        @media screen and (orientation: portrait) {
            #portrait-warning { display: flex; }
            #gameCanvas { display: none; }
        }
    </style>
</head>
<body>

<div id="portrait-warning">
    <h2>スマホを横向きにしてください</h2>
    <p>Please rotate your device to landscape mode.</p>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // コントロールUIの初期設定
    const controls = {
        move: { x: 100, y: 0, r: 50, color: 'rgba(0, 116, 217, 0.5)', activeId: null, vecX: 0, vecY: 0 },
        aim:  { x: 0, y: 0, r: 50, color: 'rgba(255, 65, 54, 0.5)', activeId: null, vecX: 0, vecY: 0 },
        fire: { x: 0, y: 0, r: 40, color: 'rgba(255, 220, 0, 0.5)', activeId: null }
    };

    // 画面サイズ調整とボタンの画面外はみ出し防止
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // 初期配置、または画面回転時にボタンが画面外にあったら画面内に戻す
        const margin = 20;
        if (controls.move.y === 0 || controls.move.y > canvas.height - margin) controls.move.y = canvas.height - 100;
        if (controls.move.x > canvas.width - margin) controls.move.x = 100;
        
        if (controls.aim.y === 0 || controls.aim.y > canvas.height - margin) controls.aim.y = canvas.height - 100;
        if (controls.aim.x === 0 || controls.aim.x > canvas.width - margin) controls.aim.x = canvas.width - 100;
        
        if (controls.fire.y === 0 || controls.fire.y > canvas.height - margin) controls.fire.y = canvas.height - 100;
        if (controls.fire.x === 0 || controls.fire.x > canvas.width - margin) controls.fire.x = canvas.width - 220;
    }
    window.addEventListener('resize', resize);
    resize();

    // ゲーム状態 (SETUP, PLAYING, LEVEL_CLEAR, GAME_OVER)
    let gameState = 'SETUP';
    let level = 1;
    let lives = 3;
    let score = 0;
    
    // セットアップ画面用のドラッグ状態
    let draggingControl = null;

    // --- タッチイベント処理 ---
    function getTouchPos(touch) {
        return { x: touch.clientX, y: touch.clientY };
    }

    function checkHitControl(x, y, control) {
        return Math.hypot(x - control.x, y - control.y) < control.r;
    }

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        
        // SETUPモード：ボタンの配置変更
        if (gameState === 'SETUP') {
            const touch = e.touches[0];
            const pos = getTouchPos(touch);
            
            // STARTボタン判定 (画面上部中央)
            if (pos.x > canvas.width/2 - 75 && pos.x < canvas.width/2 + 75 && pos.y > 20 && pos.y < 70) {
                initLevel(level);
                gameState = 'PLAYING';
                return;
            }

            if (checkHitControl(pos.x, pos.y, controls.move)) draggingControl = controls.move;
            else if (checkHitControl(pos.x, pos.y, controls.aim)) draggingControl = controls.aim;
            else if (checkHitControl(pos.x, pos.y, controls.fire)) draggingControl = controls.fire;
        } 
        // PLAYINGモード：ゲーム操作
        else if (gameState === 'PLAYING') {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const pos = getTouchPos(touch);

                // 発射ボタンタップ
                if (checkHitControl(pos.x, pos.y, controls.fire)) {
                    fireBullet();
                    controls.fire.activeId = touch.identifier;
                }
                // 移動ボタン
                else if (checkHitControl(pos.x, pos.y, controls.move) && controls.move.activeId === null) {
                    controls.move.activeId = touch.identifier;
                    updateControlVector(controls.move, pos.x, pos.y);
                }
                // 照準ボタン
                else if (checkHitControl(pos.x, pos.y, controls.aim) && controls.aim.activeId === null) {
                    controls.aim.activeId = touch.identifier;
                    updateControlVector(controls.aim, pos.x, pos.y);
                }
            }
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        
        if (gameState === 'SETUP' && draggingControl) {
            const touch = e.touches[0];
            draggingControl.x = touch.clientX;
            draggingControl.y = touch.clientY;
        } else if (gameState === 'PLAYING') {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const pos = getTouchPos(touch);
                
                if (controls.move.activeId === touch.identifier) updateControlVector(controls.move, pos.x, pos.y);
                if (controls.aim.activeId === touch.identifier) updateControlVector(controls.aim, pos.x, pos.y);
            }
        }
    }, {passive: false});

    function endTouch(e) {
        e.preventDefault();
        if (gameState === 'SETUP') {
            draggingControl = null;
        } else if (gameState === 'PLAYING') {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const id = e.changedTouches[i].identifier;
                if (controls.move.activeId === id) { controls.move.activeId = null; controls.move.vecX = 0; controls.move.vecY = 0; }
                if (controls.aim.activeId === id) { controls.aim.activeId = null; controls.aim.vecX = 0; controls.aim.vecY = 0; }
                if (controls.fire.activeId === id) { controls.fire.activeId = null; }
            }
        }
    }

    canvas.addEventListener('touchend', endTouch, {passive: false});
    canvas.addEventListener('touchcancel', endTouch, {passive: false});

    function updateControlVector(control, tx, ty) {
        let dx = tx - control.x;
        let dy = ty - control.y;
        let dist = Math.hypot(dx, dy);
        if (dist > 5) {
            control.vecX = dx / dist;
            control.vecY = dy / dist;
        } else {
            control.vecX = 0;
            control.vecY = 0;
        }
    }

    function fireBullet() {
        if (player && !player.dead && player.cooldown <= 0) {
            const spawnDist = 20; 
            const bx = player.x + Math.cos(player.angle) * spawnDist;
            const by = player.y + Math.sin(player.angle) * spawnDist;
            const speed = 6;
            bullets.push(new Bullet(bx, by, Math.cos(player.angle) * speed, Math.sin(player.angle) * speed, true));
            player.cooldown = 30; // 連射制限
        }
    }

    // --- オブジェクト定義 ---
    class Tank {
        constructor(x, y, color, type) {
            this.x = x;
            this.y = y;
            this.width = 24;
            this.height = 24;
            this.color = color;
            this.type = type; // 'player', 'stationary', 'moving'
            this.angle = 0;
            this.baseSpeed = type === 'player' ? 2.5 : (type === 'moving' ? 1.5 : 0);
            this.cooldown = 0;
            this.dead = false;
            
            // AI用変数
            this.moveTimer = 0;
            this.moveDir = 0;
        }

        draw() {
            if (this.dead) return;
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // 車体
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
            
            // 砲台
            ctx.rotate(this.angle);
            ctx.fillStyle = '#333';
            ctx.fillRect(0, -4, 20, 8);
            
            ctx.restore();
        }

        updateAI() {
            if (this.type === 'stationary' || this.type === 'moving') {
                // プレイヤーの方を向く
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                this.angle = Math.atan2(dy, dx);
                
                // 動くタイプの場合のランダム移動
                if (this.type === 'moving') {
                    this.moveTimer--;
                    if (this.moveTimer <= 0) {
                        this.moveDir = Math.random() * Math.PI * 2;
                        this.moveTimer = 60 + Math.random() * 60;
                    }
                    moveEntity(this, Math.cos(this.moveDir) * this.baseSpeed, Math.sin(this.moveDir) * this.baseSpeed);
                }

                // 射撃（難易度に応じて確率を調整）
                const fireRate = level === 1 ? 0.005 : 0.01;
                if (Math.random() < fireRate && this.cooldown <= 0) {
                    const bx = this.x + Math.cos(this.angle) * 20;
                    const by = this.y + Math.sin(this.angle) * 20;
                    bullets.push(new Bullet(bx, by, Math.cos(this.angle) * 4, Math.sin(this.angle) * 4, false));
                    this.cooldown = 90;
                }
            }
        }
    }

    class Bullet {
        constructor(x, y, vx, vy, isPlayer) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.radius = 4;
            this.isPlayer = isPlayer;
            this.bounces = 0;
            this.maxBounces = 1; 
            this.dead = false;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.isPlayer ? '#333' : '#a00';
            ctx.fill();
            ctx.closePath();
        }

        update() {
            this.x += this.vx;
            if (this.x - this.radius < 0 || this.x + this.radius > canvas.width || checkWallHit(this.x, this.y, this.radius)) {
                this.x -= this.vx;
                this.vx *= -1;
                this.bounces++;
            }

            this.y += this.vy;
            if (this.y - this.radius < 0 || this.y + this.radius > canvas.height || checkWallHit(this.x, this.y, this.radius)) {
                this.y -= this.vy;
                this.vy *= -1;
                this.bounces++;
            }

            if (this.bounces > this.maxBounces) this.dead = true;
        }
    }

    // --- ゲームロジック ---
    let player;
    let enemies = [];
    let bullets = [];
    let blocks = [];

    function checkWallHit(x, y, r) {
        for (let b of blocks) {
            if (x + r > b.x && x - r < b.x + b.w && y + r > b.y && y - r < b.y + b.h) {
                return true;
            }
        }
        return false;
    }

    function moveEntity(entity, dx, dy) {
        entity.x += dx;
        if (entity.x - entity.width/2 < 0 || entity.x + entity.width/2 > canvas.width || checkWallHit(entity.x, entity.y, entity.width/2)) {
            entity.x -= dx;
        }
