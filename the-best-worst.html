<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tank Game - Custom Controls</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #e0e0e0;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
        #portrait-warning {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: #333;
            color: white;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: sans-serif;
            text-align: center;
            touch-action: none;
        }
        @media screen and (orientation: portrait) {
            #portrait-warning { display: flex; }
        }
    </style>
</head>
<body>

<div id="portrait-warning">
    <h2>„Çπ„Éû„Éõ„ÇíÊ®™Âêë„Åç„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ</h2>
    <p>Please rotate your device to landscape mode.</p>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // „Ç≥„É≥„Éà„É≠„Éº„É´UI„ÅÆÂàùÊúüË®≠ÂÆö
    const controls = {
        move: { x: 100, y: 0, r: 50, color: 'rgba(0, 116, 217, 0.5)', activeId: null, vecX: 0, vecY: 0 },
        aim:  { x: 0, y: 0, r: 50, color: 'rgba(255, 65, 54, 0.5)', activeId: null, vecX: 0, vecY: 0 },
        fire: { x: 0, y: 0, r: 40, color: 'rgba(255, 220, 0, 0.5)', activeId: null }
    };

    function applyResize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const margin = 30;
        if (controls.move.x < margin || controls.move.x > canvas.width - margin) controls.move.x = 100;
        if (controls.aim.x < margin || controls.aim.x > canvas.width - margin) controls.aim.x = canvas.width - 100;
        if (controls.fire.x < margin || controls.fire.x > canvas.width - margin) controls.fire.x = canvas.width - 220;

        if (controls.move.y < margin || controls.move.y > canvas.height - margin) controls.move.y = canvas.height - 100;
        if (controls.aim.y < margin || controls.aim.y > canvas.height - margin) controls.aim.y = canvas.height - 100;
        if (controls.fire.y < margin || controls.fire.y > canvas.height - margin) controls.fire.y = canvas.height - 100;
    }

    let resizeTimer;
    function handleResize() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(applyResize, 200);
    }

    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleResize);
    applyResize();

    let gameState = 'SETUP';
    let level = 1;
    let lives = 3;
    let score = 0;
    let draggingControl = null;

    // --- „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„ÉàÂá¶ÁêÜ ---
    function getTouchPos(touch) {
        return { x: touch.clientX, y: touch.clientY };
    }

    function checkHitControl(x, y, control) {
        return Math.hypot(x - control.x, y - control.y) < control.r;
    }

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (gameState === 'SETUP') {
            const touch = e.touches[0];
            const pos = getTouchPos(touch);
            
            if (pos.x > canvas.width/2 - 75 && pos.x < canvas.width/2 + 75 && pos.y > 20 && pos.y < 70) {
                initLevel(level);
                gameState = 'PLAYING';
                return;
            }

            if (checkHitControl(pos.x, pos.y, controls.move)) draggingControl = controls.move;
            else if (checkHitControl(pos.x, pos.y, controls.aim)) draggingControl = controls.aim;
            else if (checkHitControl(pos.x, pos.y, controls.fire)) draggingControl = controls.fire;
        } 
        else if (gameState === 'PLAYING') {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const pos = getTouchPos(touch);

                if (checkHitControl(pos.x, pos.y, controls.fire)) {
                    fireBullet();
                    controls.fire.activeId = touch.identifier;
                }
                else if (checkHitControl(pos.x, pos.y, controls.move) && controls.move.activeId === null) {
                    controls.move.activeId = touch.identifier;
                    updateControlVector(controls.move, pos.x, pos.y);
                }
                else if (checkHitControl(pos.x, pos.y, controls.aim) && controls.aim.activeId === null) {
                    controls.aim.activeId = touch.identifier;
                    updateControlVector(controls.aim, pos.x, pos.y);
                }
            }
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (gameState === 'SETUP' && draggingControl) {
            const touch = e.touches[0];
            draggingControl.x = touch.clientX;
            draggingControl.y = touch.clientY;
        } else if (gameState === 'PLAYING') {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const pos = getTouchPos(touch);
                if (controls.move.activeId === touch.identifier) updateControlVector(controls.move, pos.x, pos.y);
                if (controls.aim.activeId === touch.identifier) updateControlVector(controls.aim, pos.x, pos.y);
            }
        }
    }, {passive: false});

    function endTouch(e) {
        e.preventDefault();
        if (gameState === 'SETUP') {
            draggingControl = null;
        } else if (gameState === 'PLAYING') {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const id = e.changedTouches[i].identifier;
                if (controls.move.activeId === id) { controls.move.activeId = null; controls.move.vecX = 0; controls.move.vecY = 0; }
                if (controls.aim.activeId === id) { controls.aim.activeId = null; controls.aim.vecX = 0; controls.aim.vecY = 0; }
                if (controls.fire.activeId === id) { controls.fire.activeId = null; }
            }
        }
    }

    canvas.addEventListener('touchend', endTouch, {passive: false});
    canvas.addEventListener('touchcancel', endTouch, {passive: false});

    function updateControlVector(control, tx, ty) {
        let dx = tx - control.x;
        let dy = ty - control.y;
        let dist = Math.hypot(dx, dy);
        if (dist > 5) {
            control.vecX = dx / dist;
            control.vecY = dy / dist;
        } else {
            control.vecX = 0;
            control.vecY = 0;
        }
    }

    function fireBullet() {
        if (player && !player.dead && player.cooldown <= 0) {
            const spawnDist = 20; 
            const bx = player.x + Math.cos(player.angle) * spawnDist;
            const by = player.y + Math.sin(player.angle) * spawnDist;
            const speed = 6;
            bullets.push(new Bullet(bx, by, Math.cos(player.angle) * speed, Math.sin(player.angle) * speed, true));
            player.cooldown = 30;
        }
    }

    // --- ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„ÉàÔºà„Éë„Éº„ÉÜ„Ç£„ÇØ„É´ÔºâÂÆöÁæ© ---
    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 4 + 1;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 1.0;
            this.decay = Math.random() * 0.03 + 0.02; // Ê∂à„Åà„Çã„Çπ„Éî„Éº„Éâ
            this.size = Math.random() * 5 + 2;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
        }
        draw() {
            if (this.life <= 0) return;
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    let particles = [];
    function createExplosion(x, y, baseColor) {
        for(let i = 0; i < 30; i++) {
            // „Éô„Éº„ÇπËâ≤„ÄÅ„Ç™„É¨„É≥„Ç∏„ÄÅÈªÑËâ≤„ÇíÊ∑∑„Åú„Å¶ÁàÜÁô∫„Å£„ÅΩ„Åè„Åô„Çã
            const colors = [baseColor, '#FF851B', '#FFDC00'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            particles.push(new Particle(x, y, color));
        }
    }

    // --- „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂÆöÁæ© ---
    class Tank {
        constructor(x, y, color, type) {
            this.x = x;
            this.y = y;
            this.width = 24;
            this.height = 24;
            this.color = color;
            this.type = type;
            this.angle = 0;
            this.baseSpeed = type === 'player' ? 2.5 : (type === 'moving' ? 1.5 : 0);
            this.cooldown = 0;
            this.dead = false;
            this.moveTimer = 0;
            this.moveDir = 0;
            
            // Êïµ„ÅÆÁô∫Â∞Ñ„Çø„Ç§„Éû„ÉºÔºàÂàùÊúüÂÄ§„ÅØÂ∞ë„Åó„Éê„É©„Åë„Åï„Åõ„ÇãÔºâ
            this.fireTimer = 60 + Math.random() * 60; 
        }

        draw() {
            if (this.dead) return;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
            ctx.rotate(this.angle);
            ctx.fillStyle = '#333';
            ctx.fillRect(0, -4, 20, 8);
            ctx.restore();
        }

        updateAI() {
            if (this.type === 'stationary' || this.type === 'moving') {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                this.angle = Math.atan2(dy, dx);
                
                if (this.type === 'moving') {
                    this.moveTimer--;
                    if (this.moveTimer <= 0) {
                        this.moveDir = Math.random() * Math.PI * 2;
                        this.moveTimer = 60 + Math.random() * 60;
                    }
                    moveEntity(this, Math.cos(this.moveDir) * this.baseSpeed, Math.sin(this.moveDir) * this.baseSpeed);
                }

                // Êïµ„ÅÆÂ∞ÑÊíÉ„É≠„Ç∏„ÉÉ„ÇØÔºà‰∏ÄÂÆöÁßíÊï∞„Åî„Å®„Å´Á¢∫ÂÆü„Å´ÊíÉ„Å§„Çà„ÅÜ„Å´Â§âÊõ¥Ôºâ
                this.fireTimer--;
                if (this.fireTimer <= 0) {
                    const bx = this.x + Math.cos(this.angle) * 20;
                    const by = this.y + Math.sin(this.angle) * 20;
                    bullets.push(new Bullet(bx, by, Math.cos(this.angle) * 4, Math.sin(this.angle) * 4, false));
                    
                    // Ê¨°„ÅÆÁô∫Â∞Ñ„Åæ„Åß„ÅÆÈñìÈöîÔºà„Çπ„ÉÜ„Éº„Ç∏„Åå‰∏ä„Åå„Çã„Åª„Å©Áü≠„Åè„Å™„ÇãÔºâ
                    // Âü∫Ê∫ñ: Lv1=Á¥Ñ3„Äú4Áßí, Lv5=Á¥Ñ1„Äú2Áßí
                    const baseInterval = Math.max(60, 240 - level * 30);
                    this.fireTimer = baseInterval + Math.random() * 60;
                }
            }
        }
    }

    class Bullet {
        constructor(x, y, vx, vy, isPlayer) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.radius = 4;
            this.isPlayer = isPlayer;
            this.bounces = 0;
            this.maxBounces = 1; 
            this.dead = false;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.isPlayer ? '#333' : '#a00';
            ctx.fill();
            ctx.closePath();
        }

        update() {
            this.x += this.vx;
            if (this.x - this.radius < 0 || this.x + this.radius > canvas.width || checkWallHit(this.x, this.y, this.radius)) {
                this.x -= this.vx;
                this.vx *= -1;
                this.bounces++;
            }

            this.y += this.vy;
            if (this.y - this.radius < 0 || this.y + this.radius > canvas.height || checkWallHit(this.x, this.y, this.radius)) {
                this.y -= this.vy;
                this.vy *= -1;
                this.bounces++;
            }

            if (this.bounces > this.maxBounces) this.dead = true;
        }
    }

    // --- „Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ ---
    let player;
    let enemies = [];
    let bullets = [];
    let blocks = [];

    function checkWallHit(x, y, r) {
        for (let b of blocks) {
            if (x + r > b.x && x - r < b.x + b.w && y + r > b.y && y - r < b.y + b.h) {
                return true;
            }
        }
        return false;
    }

    function moveEntity(entity, dx, dy) {
        entity.x += dx;
        if (entity.x - entity.width/2 < 0 || entity.x + entity.width/2 > canvas.width || checkWallHit(entity.x, entity.y, entity.width/2)) {
            entity.x -= dx;
        }
        entity.y += dy;
        if (entity.y - entity.height/2 < 0 || entity.y + entity.height/2 > canvas.height || checkWallHit(entity.x, entity.y, entity.height/2)) {
            entity.y -= dy;
        }
    }

    function initLevel(lvl) {
        player = new Tank(100, canvas.height / 2, '#0074D9', 'player');
        enemies = [];
        bullets = [];
        blocks = [];
        particles = []; // „Çπ„ÉÜ„Éº„Ç∏ÈñãÂßãÊôÇ„Å´ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„Éà„Çí„É™„Çª„ÉÉ„Éà

        blocks.push({x: canvas.width/2 - 20, y: canvas.height/4, w: 40, h: canvas.height/2});
        
        if (lvl === 1) {
            enemies.push(new Tank(canvas.width - 150, canvas.height/2, '#85144b', 'stationary'));
        } else if (lvl === 2) {
            enemies.push(new Tank(canvas.width - 150, canvas.height/4, '#85144b', 'stationary'));
            enemies.push(new Tank(canvas.width - 150, canvas.height*3/4, '#85144b', 'stationary'));
        } else if (lvl === 3) {
            enemies.push(new Tank(canvas.width - 150, canvas.height/2, '#FF4136', 'moving'));
        } else {
            const enemyCount = Math.min(lvl, 5);
            for(let i=0; i<enemyCount; i++){
                enemies.push(new Tank(canvas.width - 100 - Math.random()*200, 50 + Math.random()*(canvas.height-100), '#FF4136', 'moving'));
            }
        }
    }

    function playerHit() {
        if (player.dead) return;
        player.dead = true;
        lives--;
        
        // „Éó„É¨„Ç§„É§„ÉºÁàÜÁô∫
        createExplosion(player.x, player.y, player.color);
        
        setTimeout(() => {
            if (lives > 0) {
                bullets = [];
                player.x = 100;
                player.y = canvas.height / 2;
                player.dead = false;
            } else {
                gameState = 'GAME_OVER';
            }
        }, 1500); // ÁàÜÁô∫„ÅåË¶ã„Åà„Çã„Çà„ÅÜ„Å´„É™„Çπ„Éù„Éº„É≥„ÇíÂ∞ë„ÅóÈÅÖ„Çâ„Åõ„Çã
    }

    // --- ÊèèÁîªÈñ¢Êï∞ ---
    function drawControlUI(ctrl, label) {
        ctx.beginPath();
        ctx.arc(ctrl.x, ctrl.y, ctrl.r, 0, Math.PI * 2);
        ctx.fillStyle = ctrl.color;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'white';
        ctx.stroke();
        
        if(ctrl.vecX !== undefined && (ctrl.vecX !== 0 || ctrl.vecY !== 0)) {
            ctx.beginPath();
            ctx.arc(ctrl.x + ctrl.vecX * 20, ctrl.y + ctrl.vecY * 20, 15, 0, Math.PI*2);
            ctx.fillStyle = 'white';
            ctx.fill();
        }

        ctx.fillStyle = 'white';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        if (label === 'Áô∫Â∞Ñ') {
            ctx.fillText('üí£', ctrl.x, ctrl.y);
        } else {
            ctx.fillText(label, ctrl.x, ctrl.y - ctrl.r - 15);
        }
    }

    // --- „É°„Ç§„É≥„É´„Éº„Éó ---
    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (gameState === 'SETUP') {
            ctx.fillStyle = '#333';
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('„Éú„Çø„É≥„Çí„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶Â•Ω„Åç„Å™Â†¥ÊâÄ„Å´ÈÖçÁΩÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', canvas.width/2, canvas.height/2);

            ctx.fillStyle = '#2ECC40';
            ctx.fillRect(canvas.width/2 - 75, 20, 150, 50);
            ctx.fillStyle = 'white';
            ctx.fillText('GAME START', canvas.width/2, 45);

            drawControlUI(controls.move, 'ÁßªÂãï');
            drawControlUI(controls.aim, 'Á†≤Âè∞');
            drawControlUI(controls.fire, 'Áô∫Â∞Ñ');

            requestAnimationFrame(gameLoop);
            return;
        }

        if (gameState === 'GAME_OVER') {
            // ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„Éà„ÇíÊèèÁîª„ÅóÁ∂ö„Åë„Çã
            particles.forEach(p => { p.update(); p.draw(); });
            
            ctx.fillStyle = '#000';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
            ctx.font = '20px sans-serif';
            ctx.fillText('„Çø„ÉÉ„Éó„Åó„Å¶ÊúÄÂàù„Åã„Çâ', canvas.width/2, canvas.height/2 + 40);
            
            canvas.ontouchend = () => { 
                level = 1; lives = 3; score = 0; gameState = 'SETUP'; canvas.ontouchend = null; applyResize();
            };
            requestAnimationFrame(gameLoop);
            return;
        }

        if (gameState === 'LEVEL_CLEAR') {
            // „ÇØ„É™„Ç¢ÊôÇ„ÇÇ„Ç®„Éï„Çß„ÇØ„Éà„ÇíÊÆã„Åô
            particles.forEach(p => { p.update(); p.draw(); });

            ctx.fillStyle = '#000';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('STAGE CLEAR!', canvas.width/2, canvas.height/2);
            requestAnimationFrame(gameLoop);
            return;
        }

        // --- „Éó„É¨„Ç§‰∏≠„ÅÆÂá¶ÁêÜ ---
        if (!player.dead) {
            if (controls.move.vecX !== 0 || controls.move.vecY !== 0) {
                moveEntity(player, controls.move.vecX * player.baseSpeed, controls.move.vecY * player.baseSpeed);
            }
            if (controls.aim.vecX !== 0 || controls.aim.vecY !== 0) {
                player.angle = Math.atan2(controls.aim.vecY, controls.aim.vecX);
            }
            if (player.cooldown > 0) player.cooldown--;
        }

        ctx.fillStyle = '#8B4513';
        blocks.forEach(b => {
            ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.strokeRect(b.x, b.y, b.w, b.h);
        });

        enemies.forEach(enemy => {
            enemy.updateAI();
            enemy.draw();
        });

        bullets.forEach(bullet => {
            bullet.update();
            bullet.draw();

            if (!bullet.dead) {
                // „Éó„É¨„Ç§„É§„Éº„Å∏„ÅÆÂΩì„Åü„ÇäÂà§ÂÆöÔºàÊïµ„ÅÆÂºæ„ÄÅ„Åæ„Åü„ÅØËá™ÂàÜ„ÅÆÂºæ„ÅåË∑≥„Å≠Ëøî„Å£„Å¶„Åç„ÅüÊôÇÔºâ
                if ((!bullet.isPlayer || bullet.bounces > 0) && !player.dead) {
                    if (Math.hypot(bullet.x - player.x, bullet.y - player.y) < player.width/2 + bullet.radius) {
                        bullet.dead = true;
                        playerHit();
                    }
                }

                // Êïµ„Å∏„ÅÆÂΩì„Åü„ÇäÂà§ÂÆöÔºà„Éó„É¨„Ç§„É§„Éº„ÅÆÂºæ„ÄÅ„Åæ„Åü„ÅØ„ÄåË∑≥„Å≠Ëøî„Å£„ÅüÊïµËá™Ë∫´„ÅÆÂºæ„ÄçÔºâ
                if (bullet.isPlayer || (!bullet.isPlayer && bullet.bounces > 0)) {
                    enemies.forEach(enemy => {
                        if (!enemy.dead && Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y) < enemy.width/2 + bullet.radius) {
                            enemy.dead = true;
                            bullet.dead = true;
                            
                            // Êïµ„ÅÆÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„Éà„ÇíÁîüÊàê
                            createExplosion(enemy.x, enemy.y, enemy.color);
                            score += 100; // Ëá™ÁàÜ„Åß„ÇÇ„Çπ„Ç≥„Ç¢Âä†ÁÆó
                        }
                    });
                }
            }
        });

        // ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„Éà„ÅÆÊõ¥Êñ∞„Å®ÊèèÁîª
        particles.forEach(p => { p.update(); p.draw(); });
        particles = particles.filter(p => p.life > 0);

        enemies = enemies.filter(e => !e.dead);
        bullets = bullets.filter(b => !b.dead);

        if (enemies.length === 0 && !player.dead) {
            gameState = 'LEVEL_CLEAR';
            setTimeout(() => {
                level++;
                initLevel(level);
                gameState = 'PLAYING';
            }, 2000);
        }

        player.draw();

        drawControlUI(controls.move, '');
        drawControlUI(controls.aim, '');
        drawControlUI(controls.fire, 'Áô∫Â∞Ñ');

  
