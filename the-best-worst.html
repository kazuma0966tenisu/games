<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tank Game - Custom Controls</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #e0e0e0;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
        /* ç¸¦ç”»é¢ã®ã¨ãã«è¡¨ç¤ºã™ã‚‹è­¦å‘Šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
        #portrait-warning {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #333;
            color: white;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: sans-serif;
            text-align: center;
        }
        @media screen and (orientation: portrait) {
            #portrait-warning { display: flex; }
            #gameCanvas { display: none; }
        }
    </style>
</head>
<body>

<div id="portrait-warning">
    <h2>ã‚¹ãƒãƒ›ã‚’æ¨ªå‘ãã«ã—ã¦ãã ã•ã„</h2>
    <p>Please rotate your device to landscape mode.</p>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ç”»é¢ã‚µã‚¤ã‚ºèª¿æ•´
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ (SETUP, PLAYING, LEVEL_CLEAR, GAME_OVER)
    let gameState = 'SETUP';
    let level = 1;
    let lives = 3;
    let score = 0;

    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«UIã®è¨­å®š
    const controls = {
        move: { x: 100, y: canvas.height - 100, r: 50, color: 'rgba(0, 116, 217, 0.5)', activeId: null, vecX: 0, vecY: 0 },
        aim:  { x: canvas.width - 100, y: canvas.height - 100, r: 50, color: 'rgba(255, 65, 54, 0.5)', activeId: null, vecX: 0, vecY: 0 },
        fire: { x: canvas.width - 220, y: canvas.height - 100, r: 40, color: 'rgba(255, 220, 0, 0.5)', activeId: null }
    };
    
    // ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ç”»é¢ç”¨ã®ãƒ‰ãƒ©ãƒƒã‚°çŠ¶æ…‹
    let draggingControl = null;

    // --- ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç† ---
    function getTouchPos(touch) {
        return { x: touch.clientX, y: touch.clientY };
    }

    function checkHitControl(x, y, control) {
        return Math.hypot(x - control.x, y - control.y) < control.r;
    }

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        
        // SETUPãƒ¢ãƒ¼ãƒ‰ï¼šãƒœã‚¿ãƒ³ã®é…ç½®å¤‰æ›´
        if (gameState === 'SETUP') {
            const touch = e.touches[0];
            const pos = getTouchPos(touch);
            
            // STARTãƒœã‚¿ãƒ³åˆ¤å®š (ç”»é¢ä¸Šéƒ¨ä¸­å¤®)
            if (pos.x > canvas.width/2 - 75 && pos.x < canvas.width/2 + 75 && pos.y > 20 && pos.y < 70) {
                initLevel(level);
                gameState = 'PLAYING';
                return;
            }

            if (checkHitControl(pos.x, pos.y, controls.move)) draggingControl = controls.move;
            else if (checkHitControl(pos.x, pos.y, controls.aim)) draggingControl = controls.aim;
            else if (checkHitControl(pos.x, pos.y, controls.fire)) draggingControl = controls.fire;
        } 
        // PLAYINGãƒ¢ãƒ¼ãƒ‰ï¼šã‚²ãƒ¼ãƒ æ“ä½œ
        else if (gameState === 'PLAYING') {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const pos = getTouchPos(touch);

                // ç™ºå°„ãƒœã‚¿ãƒ³ã‚¿ãƒƒãƒ—
                if (checkHitControl(pos.x, pos.y, controls.fire)) {
                    fireBullet();
                    controls.fire.activeId = touch.identifier;
                }
                // ç§»å‹•ãƒœã‚¿ãƒ³
                else if (checkHitControl(pos.x, pos.y, controls.move) && controls.move.activeId === null) {
                    controls.move.activeId = touch.identifier;
                    updateControlVector(controls.move, pos.x, pos.y);
                }
                // ç…§æº–ãƒœã‚¿ãƒ³
                else if (checkHitControl(pos.x, pos.y, controls.aim) && controls.aim.activeId === null) {
                    controls.aim.activeId = touch.identifier;
                    updateControlVector(controls.aim, pos.x, pos.y);
                }
            }
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        
        if (gameState === 'SETUP' && draggingControl) {
            const touch = e.touches[0];
            draggingControl.x = touch.clientX;
            draggingControl.y = touch.clientY;
        } else if (gameState === 'PLAYING') {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const pos = getTouchPos(touch);
                
                if (controls.move.activeId === touch.identifier) updateControlVector(controls.move, pos.x, pos.y);
                if (controls.aim.activeId === touch.identifier) updateControlVector(controls.aim, pos.x, pos.y);
            }
        }
    }, {passive: false});

    function endTouch(e) {
        e.preventDefault();
        if (gameState === 'SETUP') {
            draggingControl = null;
        } else if (gameState === 'PLAYING') {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const id = e.changedTouches[i].identifier;
                if (controls.move.activeId === id) { controls.move.activeId = null; controls.move.vecX = 0; controls.move.vecY = 0; }
                if (controls.aim.activeId === id) { controls.aim.activeId = null; controls.aim.vecX = 0; controls.aim.vecY = 0; }
                if (controls.fire.activeId === id) { controls.fire.activeId = null; }
            }
        }
    }

    canvas.addEventListener('touchend', endTouch, {passive: false});
    canvas.addEventListener('touchcancel', endTouch, {passive: false});

    function updateControlVector(control, tx, ty) {
        let dx = tx - control.x;
        let dy = ty - control.y;
        let dist = Math.hypot(dx, dy);
        if (dist > 5) {
            control.vecX = dx / dist;
            control.vecY = dy / dist;
        } else {
            control.vecX = 0;
            control.vecY = 0;
        }
    }

    function fireBullet() {
        if (player && !player.dead && player.cooldown <= 0) {
            // å¼¾ã®å‡ºç¾ä½ç½®ã‚’è»Šä½“ã®å°‘ã—å¤–å´ã«ã™ã‚‹ï¼ˆè‡ªçˆ†é˜²æ­¢ï¼‰
            const spawnDist = 20; 
            const bx = player.x + Math.cos(player.angle) * spawnDist;
            const by = player.y + Math.sin(player.angle) * spawnDist;
            const speed = 6;
            bullets.push(new Bullet(bx, by, Math.cos(player.angle) * speed, Math.sin(player.angle) * speed, true));
            player.cooldown = 30; // é€£å°„åˆ¶é™
        }
    }

    // --- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå®šç¾© ---
    class Tank {
        constructor(x, y, color, type) {
            this.x = x;
            this.y = y;
            this.width = 24;
            this.height = 24;
            this.color = color;
            this.type = type; // 'player', 'stationary', 'moving'
            this.angle = 0;
            this.baseSpeed = type === 'player' ? 2.5 : (type === 'moving' ? 1.5 : 0);
            this.cooldown = 0;
            this.dead = false;
            
            // AIç”¨å¤‰æ•°
            this.moveTimer = 0;
            this.moveDir = 0;
        }

        draw() {
            if (this.dead) return;
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // è»Šä½“
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
            
            // ç ²å°
            ctx.rotate(this.angle);
            ctx.fillStyle = '#333';
            ctx.fillRect(0, -4, 20, 8);
            
            ctx.restore();
        }

        updateAI() {
            if (this.type === 'stationary' || this.type === 'moving') {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ–¹ã‚’å‘ã
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                this.angle = Math.atan2(dy, dx);
                
                // å‹•ãã‚¿ã‚¤ãƒ—ã®å ´åˆã®ãƒ©ãƒ³ãƒ€ãƒ ç§»å‹•
                if (this.type === 'moving') {
                    this.moveTimer--;
                    if (this.moveTimer <= 0) {
                        this.moveDir = Math.random() * Math.PI * 2;
                        this.moveTimer = 60 + Math.random() * 60;
                    }
                    moveEntity(this, Math.cos(this.moveDir) * this.baseSpeed, Math.sin(this.moveDir) * this.baseSpeed);
                }

                // å°„æ’ƒï¼ˆé›£æ˜“åº¦ã«å¿œã˜ã¦ç¢ºç‡ã‚’èª¿æ•´ï¼‰
                const fireRate = level === 1 ? 0.005 : 0.01;
                if (Math.random() < fireRate && this.cooldown <= 0) {
                    const bx = this.x + Math.cos(this.angle) * 20;
                    const by = this.y + Math.sin(this.angle) * 20;
                    bullets.push(new Bullet(bx, by, Math.cos(this.angle) * 4, Math.sin(this.angle) * 4, false));
                    this.cooldown = 90; // æ•µã®é€£å°„ã¯é…ã„
                }
            }
        }
    }

    class Bullet {
        constructor(x, y, vx, vy, isPlayer) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.radius = 4;
            this.isPlayer = isPlayer;
            this.bounces = 0;
            this.maxBounces = 1; 
            this.dead = false;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.isPlayer ? '#333' : '#a00';
            ctx.fill();
            ctx.closePath();
        }

        update() {
            // Xè»¸ã®ç§»å‹•ã¨åå°„
            this.x += this.vx;
            if (this.x - this.radius < 0 || this.x + this.radius > canvas.width || checkWallHit(this.x, this.y, this.radius)) {
                this.x -= this.vx;
                this.vx *= -1;
                this.bounces++;
            }

            // Yè»¸ã®ç§»å‹•ã¨åå°„
            this.y += this.vy;
            if (this.y - this.radius < 0 || this.y + this.radius > canvas.height || checkWallHit(this.x, this.y, this.radius)) {
                this.y -= this.vy;
                this.vy *= -1;
                this.bounces++;
            }

            if (this.bounces > this.maxBounces) this.dead = true;
        }
    }

    // --- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ ---
    let player;
    let enemies = [];
    let bullets = [];
    let blocks = [];

    // å£ã¨ã®è¡çªåˆ¤å®š (åº§æ¨™ã¨åŠå¾„ã‚’æ¸¡ã—ã¦åˆ¤å®š)
    function checkWallHit(x, y, r) {
        for (let b of blocks) {
            if (x + r > b.x && x - r < b.x + b.w && y + r > b.y && y - r < b.y + b.h) {
                return true;
            }
        }
        return false;
    }

    // å£æŠœã‘ã‚’é˜²ããŸã‚ã®ç§»å‹•é–¢æ•°
    function moveEntity(entity, dx, dy) {
        // Xè»¸ã‚’å…ˆã«ç§»å‹•ã—ã¦åˆ¤å®š
        entity.x += dx;
        if (entity.x - entity.width/2 < 0 || entity.x + entity.width/2 > canvas.width || checkWallHit(entity.x, entity.y, entity.width/2)) {
            entity.x -= dx; // ã¶ã¤ã‹ã£ãŸã‚‰æˆ»ã™
        }
        // Yè»¸ã‚’ç§»å‹•ã—ã¦åˆ¤å®š
        entity.y += dy;
        if (entity.y - entity.height/2 < 0 || entity.y + entity.height/2 > canvas.height || checkWallHit(entity.x, entity.y, entity.height/2)) {
            entity.y -= dy; // ã¶ã¤ã‹ã£ãŸã‚‰æˆ»ã™
        }
    }

    function initLevel(lvl) {
        player = new Tank(100, canvas.height / 2, '#0074D9', 'player');
        enemies = [];
        bullets = [];
        blocks = [];

        // å›ºå®šã®å£é…ç½®
        blocks.push({x: canvas.width/2 - 20, y: canvas.height/4, w: 40, h: canvas.height/2});
        
        // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸæ•µã®é…ç½®ï¼ˆæ®µéšçš„ã«é›£ã—ãã™ã‚‹ï¼‰
        if (lvl === 1) {
            enemies.push(new Tank(canvas.width - 150, canvas.height/2, '#85144b', 'stationary'));
        } else if (lvl === 2) {
            enemies.push(new Tank(canvas.width - 150, canvas.height/4, '#85144b', 'stationary'));
            enemies.push(new Tank(canvas.width - 150, canvas.height*3/4, '#85144b', 'stationary'));
        } else if (lvl === 3) {
            enemies.push(new Tank(canvas.width - 150, canvas.height/2, '#FF4136', 'moving'));
        } else {
            // Lv4ä»¥é™ã¯å‹•ãæ•µãŒå¢—ãˆã‚‹
            const enemyCount = Math.min(lvl, 5);
            for(let i=0; i<enemyCount; i++){
                enemies.push(new Tank(canvas.width - 100 - Math.random()*200, 50 + Math.random()*(canvas.height-100), '#FF4136', 'moving'));
            }
        }
    }

    function playerHit() {
        if (player.dead) return;
        player.dead = true;
        lives--;
        
        setTimeout(() => {
            if (lives > 0) {
                // ãƒªã‚¹ãƒãƒ¼ãƒ³ï¼ˆå¼¾ã‚’æ¶ˆã™ï¼‰
                bullets = [];
                player.x = 100;
                player.y = canvas.height / 2;
                player.dead = false;
            } else {
                gameState = 'GAME_OVER';
            }
        }, 1000);
    }

    // --- æç”»é–¢æ•° ---
    function drawControlUI(ctrl, label) {
        ctx.beginPath();
        ctx.arc(ctrl.x, ctrl.y, ctrl.r, 0, Math.PI * 2);
        ctx.fillStyle = ctrl.color;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'white';
        ctx.stroke();
        
        // ä¸­å¿ƒç‚¹
        if(ctrl.vecX !== undefined) {
            ctx.beginPath();
            ctx.arc(ctrl.x + ctrl.vecX * 20, ctrl.y + ctrl.vecY * 20, 15, 0, Math.PI*2);
            ctx.fillStyle = 'white';
            ctx.fill();
        }

        ctx.fillStyle = 'white';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // ç™ºå°„ãƒœã‚¿ãƒ³ã®ç ²å¼¾ãƒãƒ¼ã‚¯
        if (label === 'ç™ºå°„') {
            ctx.fillText('ğŸ’£', ctrl.x, ctrl.y);
        } else {
            ctx.fillText(label, ctrl.x, ctrl.y - ctrl.r - 15);
        }
    }

    // --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ---
    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (gameState === 'SETUP') {
            // ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ç”»é¢
            ctx.fillStyle = '#333';
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('ãƒœã‚¿ãƒ³ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å¥½ããªå ´æ‰€ã«é…ç½®ã—ã¦ãã ã•ã„', canvas.width/2, canvas.height/2);

            // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³
            ctx.fillStyle = '#2ECC40';
            ctx.fillRect(canvas.width/2 - 75, 20, 150, 50);
            ctx.fillStyle = 'white';
            ctx.fillText('GAME START', canvas.width/2, 45);

            drawControlUI(controls.move, 'ç§»å‹•');
            drawControlUI(controls.aim, 'ç ²å°');
            drawControlUI(controls.fire, 'ç™ºå°„');

            requestAnimationFrame(gameLoop);
            return;
        }

        if (gameState === 'GAME_OVER') {
            ctx.fillStyle = '#000';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
            ctx.font = '20px sans-serif';
            ctx.fillText('ã‚¿ãƒƒãƒ—ã—ã¦æœ€åˆã‹ã‚‰', canvas.width/2, canvas.height/2 + 40);
            
            canvas.ontouchend = () => { 
                level = 1; lives = 3; score = 0; gameState = 'SETUP'; canvas.ontouchend = null; 
            };
            requestAnimationFrame(gameLoop);
            return;
        }

        if (gameState === 'LEVEL_CLEAR') {
            ctx.fillStyle = '#000';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('STAGE CLEAR!', canvas.width/2, canvas.height/2);
            requestAnimationFrame(gameLoop);
            return;
        }

        // --- ãƒ—ãƒ¬ã‚¤ä¸­ã®å‡¦ç† ---
        
        if (!player.dead) {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•
            if (controls.move.vecX !== 0 || controls.move.vecY !== 0) {
                moveEntity(player, controls.move.vecX * player.baseSpeed, controls.move.vecY * player.baseSpeed);
            }
            // ç ²å°å›è»¢
            if (controls.aim.vecX !== 0 || controls.aim.vecY !== 0) {
                player.angle = Math.atan2(controls.aim.vecY, controls.aim.vecX);
            }
            if (player.cooldown > 0) player.cooldown--;
        }

        // å£ã®æç”»
        ctx.fillStyle = '#8B4513';
        blocks.forEach(b => {
            ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.strokeRect(b.x, b.y, b.w, b.h);
        });

        // æ•µã®å‡¦ç†
        enemies.forEach(enemy => {
            enemy.updateAI();
            enemy.draw();
        });

        // å¼¾ã®å‡¦ç†ã¨å½“ãŸã‚Šåˆ¤å®š
        bullets.forEach(bullet => {
            bullet.update();
            bullet.draw();

            // å¼¾ vs ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
            if (!bullet.dead) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆæ•µã®å¼¾ã€ã¾ãŸã¯è‡ªåˆ†ã®å¼¾ãŒè·³ã­è¿”ã£ã¦ããŸæ™‚ï¼‰
                if ((!bullet.isPlayer || bullet.bounces > 0) && !player.dead) {
                    if (Math.hypot(bullet.x - player.x, bullet.y - player.y) < player.width/2 + bullet.radius) {
                        bullet.dead = true;
                        playerHit();
                    }
                }

                // æ•µã¸ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ï¼‰
                if (bullet.isPlayer) {
                    enemies.forEach(enemy => {
                        if (!enemy.dead && Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y) < enemy.width/2 + bullet.radius) {
                            enemy.dead = true;
                            bullet.dead = true;
                            score += 100;
                        }
                    });
                }
            }
        });

        enemies = enemies.filter(e => !e.dead);
        bullets = bullets.filter(b => !b.dead);

        // ã‚¯ãƒªã‚¢åˆ¤å®š
        if (enemies.length === 0 && !player.dead) {
            gameState = 'LEVEL_CLEAR';
            setTimeout(() => {
                level++;
                initLevel(level);
                gameState = 'PLAYING';
            }, 2000);
        }

        player.draw();

        // UIæç”»
        drawControlUI(controls.move, '');
        drawControlUI(controls.aim, '');
        drawControlUI(controls.fire, 'ç™ºå°„');

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
        ctx.fillStyle = '#333';
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`Stage: ${level}  Score: ${score}  å‘½: ${'â¤ï¸'.repeat(lives)}`, 20, 30);

        requestAnimationFrame(gameLoop);
    }

    // åˆæœŸèµ·å‹•ï¼ˆSETUPçŠ¶æ…‹ã§å¾…æ©Ÿï¼‰
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
